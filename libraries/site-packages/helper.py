def distance(x1,y1,x2,y2):
    return sqrt( pow((y2 - y1),2) + pow((x2 - x1),2) )

def generate_random_pts_min_dist_apart(width, height, min_dist, num_pts):
    points = {}
    for i in range(num_pts):
        if i > 0:
            found_valid_point = False
            while not found_valid_point:
                x = int(random(width))
                y = int(random(height))
                found_valid_point = True
                for j in range(1,i+1):
                    if distance(x,y,points[i-j][0],points[i-j][1]) < min_dist:  # at least one point is too close
                        found_valid_point = False
                        break
                if found_valid_point:
                    points[i] = (x,y)
                    break
        else:
            x = int(random(width))
            y = int(random(height))
            points[i] = (x,y)

    return points


def radon_transform(image, theta_range):
    """Compute the Radon transform of an image for a range of angles
    
    Parameters:
    - image: 2D list representing the grayscale image
    - theta_range: list of angles
    
    Returns:
    - radon_image: 2D list containing the Radon transform
    """
    
    rows = len(image)
    cols = len(image[0])
    
    # Initialize output image
    diag_len = int(math.ceil(math.sqrt(rows**2 + cols**2)))
    radon_image = [[0 for _ in range(len(theta_range))] for _ in range(diag_len)]
    
    # Create coordinate grid for the image
    x = [[j-cols//2 for j in range(cols)] for _ in range(rows)]
    y = [[i-rows//2 for _ in range(cols)] for i in range(rows)]
    
    # Loop over each angle
    for i, theta in enumerate(theta_range):
        # Calculate cosine and sine values for rotation
        cos_theta = math.cos(math.radians(theta))
        sin_theta = math.sin(math.radians(theta))
        
        # Loop over each pixel
        for r in range(-diag_len // 2, diag_len // 2):
            s = 0
            for row in range(rows):
                for col in range(cols):
                    x_rot = x[row][col] * cos_theta + y[row][col] * sin_theta
                    if abs(x_rot - r) < 1.0:  # This tolerance can be adjusted
                        s += image[row][col]
            radon_image[r + diag_len // 2][i] = s
            
    return radon_image


def radial_gradient_whole_canvas(width,height,start_color,stop_color,num_steps):
    noStroke()
    for i in range(num_steps):
        if i == 0:
            circle_color = start_color
        elif i == (num_steps-1):
            circle_color = stop_color
        else:
            circle_color = lerpColor(start_color,stop_color,(i*1.0/num_steps))
        
        radius = ((num_steps-i)*1.0/num_steps)*distance(0,0,width/2,height/2)
        fill(circle_color)
        circle(width/2,height/2,radius*2)


def radial_gradient(x,y,radius,start_color,stop_color,num_steps):
    noStroke()
    for i in range(num_steps):
        if i == 0:
            circle_color = start_color
        elif i == (num_steps-1):
            circle_color = stop_color
        else:
            circle_color = lerpColor(start_color,stop_color,(i*1.0/num_steps))
        
        iteradius = ((num_steps-i)*1.0/num_steps)*radius
        fill(circle_color)
        circle(x,y,iteradius*2)

